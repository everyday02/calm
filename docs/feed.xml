<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Follow your heart</title>
    <description>何航 | 博客 | Web | 前端 | 全栈 | JavaScript</description>
    <link>http://hehangblog.com/</link>
    <atom:link href="http://hehangblog.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 31 May 2017 18:15:41 +0800</pubDate>
    <lastBuildDate>Wed, 31 May 2017 18:15:41 +0800</lastBuildDate>
    <generator>Jekyll v3.4.1</generator>
    
      <item>
        <title>Webpack2 学习指南</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;记录了个人在学习webpack2中写的一些demos和过程遇到的坑点。&lt;/p&gt;

&lt;h3 id=&quot;section&quot;&gt;如何开始&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;安装必须的2个包,webpack 和 webpack-dev-server到全局环境。
    &lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; npm i -g webpack webpack-dev-server
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;接着，进入demo01, 阅读&lt;code&gt;README.md&lt;/code&gt;开始学习。&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;webpack2---&quot;&gt;webpack2 - 基础教程&lt;/h3&gt;

&lt;p&gt;基础教程中，并未使用到React/Angualr/vue，减低学习成本，仅仅是最基础的javaScript代码。&lt;/p&gt;

&lt;p&gt;主要针对已有一定前端基础的同学，看不懂的请先打好前端基础。&lt;/p&gt;

&lt;p&gt;(内容会持续更新…)&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo01&quot;&gt;demo01 Entry:入口文件&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo02&quot;&gt;demo02 Babel:支持es6语法&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo03&quot;&gt;demo03 HMR:模块热更新（替换)&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo04&quot;&gt;demo04 Caching:缓存&lt;/a&gt;.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo05&quot;&gt;demo05 Externals:外部扩展&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo06&quot;&gt;demo06 Always:常用Loaders&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;a href=&quot;/demo07&quot;&gt;demo07 Loader:常用Plugins&lt;/a&gt;&lt;/p&gt;
    &lt;h3 id=&quot;webpack2----1&quot;&gt;webpack2 - 高级教程&lt;/h3&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;高级教程:为了减低demo之间的耦合，&lt;code&gt;package.json&lt;/code&gt;文件分别放置在每个demo文件夹下，保证独立性。&lt;/p&gt;

&lt;p&gt;结合大量生态插件，代码调优等，进行前端项目环境搭建。&lt;/p&gt;
</description>
        <pubDate>Wed, 04 May 2016 00:00:00 +0800</pubDate>
        <link>http://hehangblog.com/2016/05/04/webpack/</link>
        <guid isPermaLink="true">http://hehangblog.com/2016/05/04/webpack/</guid>
        
        <category>WebPack</category>
        
        
      </item>
    
      <item>
        <title>Dockerfile的书写规范</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;dockerfile&quot;&gt;Dockerfile的书写规范&lt;/h3&gt;

&lt;p&gt;Dockerfile的指令是忽略大小写的，建议使用大写，使用 # 作为注释，每一行只支持一条指令，每条指令可以携带多个参数。&lt;/p&gt;

&lt;p&gt;Dockerfile的指令根据作用可以分为两种，构建指令和设置指令。&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;构建指令用于构建image，其指定的操作不会在运行image的容器上执行；&lt;/li&gt;
  &lt;li&gt;设置指令用于设置image的属性，其指定的操作将在运行image的容器中执行。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;fromimage&quot;&gt;FROM（指定基础image）&lt;/h4&gt;

&lt;p&gt;构建指令，必须指定且需要在Dockerfile其他指令的前面。后续的指令都依赖于该指令指定的image。FROM指令指定的基础image可以是官方远程仓库中的，也可以位于本地仓库。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# FROM &amp;lt;image&amp;gt; 指定基础image为该image的最后修改的版本&lt;/span&gt;
FROM ubuntu

&lt;span class=&quot;c&quot;&gt;# or&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# FROM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt; 指定基础image为该image的一个tag版本。&lt;/span&gt;
FROM ubuntu:14.04

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;maintainer&quot;&gt;MAINTAINER（用来指定镜像创建者信息）&lt;/h4&gt;
&lt;p&gt;构建指令，用于将image的制作者相关的信息写入到image中。当我们对该image执行docker inspect命令时，输出中有相应的字段记录该信息。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;MAINTAINER &amp;lt;name&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;run&quot;&gt;RUN（安装软件用）&lt;/h4&gt;
&lt;p&gt;构建指令，RUN可以运行任何被基础image支持的命令。如基础image选择了ubuntu，那么软件管理部分只能使用ubuntu的命令。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# RUN &amp;lt;command&amp;gt; (the command is run in a shell - `/bin/sh -c`)  &lt;/span&gt;
RUN apt-get update
&lt;span class=&quot;c&quot;&gt;# or&lt;/span&gt;

&lt;span class=&quot;c&quot;&gt;# RUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot; ... ]  (exec form)  &lt;/span&gt;
RUN &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'apt-get'&lt;/span&gt;, &lt;span class=&quot;s1&quot;&gt;'update'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;cmdcontainer&quot;&gt;CMD（设置container启动时执行的操作）&lt;/h4&gt;
&lt;p&gt;设置指令，用于container启动时指定的操作。该操作可以是执行自定义脚本，也可以是执行系统命令。该指令只能在文件中存在一次，如果有多个，则只执行最后一条。&lt;/p&gt;

&lt;p&gt;该指令有三种格式:&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (like an exec, this is the preferred form)  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# CMD command param1 param2 (as a shell)  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;当Dockerfile指定了ENTRYPOINT，那么使用下面的格式：&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# CMD [&quot;param1&quot;,&quot;param2&quot;] (as default parameters to ENTRYPOINT)  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ENTRYPOINT指定的是一个可执行的脚本或者程序的路径，该指定的脚本或者程序将会以param1和param2作为参数执行。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;所以如果CMD指令使用上面的形式，那么Dockerfile中必须要有配套的ENTRYPOINT。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;entrypointcontainer&quot;&gt;ENTRYPOINT（设置container启动时执行的操作）&lt;/h4&gt;
&lt;p&gt;设置指令，指定容器启动时执行的命令，可以多次设置，但是只有最后一个有效。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# ENTRYPOINT [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;] (like an exec, the preferred form)  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# ENTRYPOINT command param1 param2 (as a shell)  &lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;该指令的使用分为两种情况，一种是独自使用，另一种和CMD指令配合使用。
当独自使用时，如果你还使用了CMD命令且CMD是一个完整的可执行的命令，那么CMD指令和ENTRYPOINT会互相覆盖只有最后一个CMD或者ENTRYPOINT有效。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;
&lt;span class=&quot;c&quot;&gt;# CMD指令将不会被执行，只有ENTRYPOINT指令被执行  &lt;/span&gt;
CMD &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; “Hello, World!”  
ENTRYPOINT ls -l  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;另一种用法和CMD指令配合使用来指定ENTRYPOINT的默认参数，这时CMD指令不是一个完整的可执行命令，仅仅是参数部分；ENTRYPOINT指令只能使用JSON方式指定执行命令，而不能指定参数。&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;FROM ubuntu  
CMD &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;-l&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
ENTRYPOINT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/usr/bin/ls&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;usercontainer&quot;&gt;USER（设置container容器的用户）&lt;/h4&gt;

&lt;p&gt;设置指令，设置启动容器的用户，默认是root用户。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# 指定memcached的运行用户  &lt;/span&gt;
ENTRYPOINT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;memcached&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
USER daemon  
&lt;span class=&quot;c&quot;&gt;# or&lt;/span&gt;
ENTRYPOINT &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;memcached&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;-u&quot;&lt;/span&gt;, &lt;span class=&quot;s2&quot;&gt;&quot;daemon&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;expose&quot;&gt;EXPOSE（指定容器需要映射到宿主机器的端口）&lt;/h4&gt;

&lt;p&gt;设置指令，该指令会将容器中的端口映射成宿主机器中的某个端口。当你需要访问容器的时候，可以不是用容器的IP地址而是使用宿主机器的IP地址和映射后的端口。要完成整个操作需要两个步骤，首先在Dockerfile使用EXPOSE设置需要映射的容器端口，然后在运行容器的时候指定-p选项加上EXPOSE设置的端口，这样EXPOSE设置的端口号会被随机映射成宿主机器中的一个端口号。也可以指定需要映射到宿主机器的那个端口，这时要确保宿主机器上的端口号没有被使用。EXPOSE指令可以一次设置多个端口号，相应的运行容器的时候，可以配套的多次使用-p选项。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# EXPOSE &amp;lt;port&amp;gt; [&amp;lt;port&amp;gt;...]  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# 映射一个端口  &lt;/span&gt;
EXPOSE 3306  
&lt;span class=&quot;c&quot;&gt;# 相应的运行容器使用的命令  &lt;/span&gt;
docker run -p 3306 image  

&lt;span class=&quot;c&quot;&gt;# 映射多个端口  &lt;/span&gt;
EXPOSE 3306 port2 port3  
&lt;span class=&quot;c&quot;&gt;# 相应的运行容器使用的命令  &lt;/span&gt;
docker run -p port1 -p port2 -p port3 image  
&lt;span class=&quot;c&quot;&gt;# 还可以指定需要映射到宿主机器上的某个端口号  &lt;/span&gt;
docker run -p host_port1:port1 -p host_port2:port2 -p host_port3:port3 image  

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;端口映射是docker比较重要的一个功能，原因在于我们每次运行容器的时候容器的IP地址不能指定而是在桥接网卡的地址范围内随机生成的。宿主机器的IP地址是固定的，我们可以将容器的端口的映射到宿主机器上的一个端口，免去每次访问容器中的某个服务时都要查看容器的IP的地址。对于一个运行的容器，可以使用docker port加上容器中需要映射的端口和容器的ID来查看该端口号在宿主机器上的映射端口。&lt;/p&gt;

&lt;h4 id=&quot;env&quot;&gt;ENV（用于设置环境变量）&lt;/h4&gt;

&lt;p&gt;构建指令，在image中设置一个环境变量。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# ENV &amp;lt;key&amp;gt; &amp;lt;value&amp;gt;  &lt;/span&gt;
ENV JAVA_HOME /path/to/java/dirent
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;设置了后，后续的RUN命令都可以使用，container启动后，可以通过docker inspect查看这个环境变量，也可以通过在docker run –env key=value时设置或修改环境变量。&lt;/p&gt;

&lt;h4 id=&quot;addsrccontainerdest&quot;&gt;ADD（从src复制文件到container的dest路径）&lt;/h4&gt;

&lt;p&gt;构建指令，所有拷贝到container中的文件和文件夹权限为0755，uid和gid为0；&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;如果是一个目录，那么会将该目录下的所有文件添加到container中，不包括目录；&lt;/li&gt;
  &lt;li&gt;如果文件是可识别的压缩格式，则docker会帮忙解压缩（注意压缩格式）；&lt;/li&gt;
  &lt;li&gt;如果&amp;lt;src&amp;gt;是文件且&amp;lt;dest&amp;gt;中不使用斜杠结束，则会将&amp;lt;dest&amp;gt;视为文件，&amp;lt;src&amp;gt;的内容会写入&amp;lt;dest&amp;gt;；&lt;/li&gt;
  &lt;li&gt;如果&amp;lt;src&amp;gt;是文件且&amp;lt;dest&amp;gt;中使用斜杠结束，则会&amp;lt;src&amp;gt;文件拷贝到&amp;lt;dest&amp;gt;目录下。&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ADD &amp;lt;src&amp;gt; &amp;lt;dest&amp;gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&amp;lt;src&amp;gt; 是相对被构建的源目录的相对路径，可以是文件或目录的路径，也可以是一个远程的文件url;
&amp;lt;dest&amp;gt; 是container中的绝对路径&lt;/p&gt;

&lt;h4 id=&quot;volume&quot;&gt;VOLUME（指定挂载点)）&lt;/h4&gt;
&lt;p&gt;设置指令，使容器中的一个目录具有持久化存储数据的功能，该目录可以被容器本身使用，也可以共享给其他容器使用。&lt;/p&gt;

&lt;p&gt;我们知道容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。当容器中的应用有持久化数据的需求时可以在Dockerfile中使用该指令。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# VOLUME [&quot;&amp;lt;mountpoint&amp;gt;&quot;]  &lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# VOLUME [&quot;/dir_1&quot;, &quot;/dir_2&quot; ..]&lt;/span&gt;
FROM base  
VOLUME &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;/tmp/data&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;运行通过该Dockerfile生成image的容器，/tmp/data目录中的数据在容器关闭后，里面的数据还存在。&lt;/p&gt;

&lt;p&gt;例如另一个容器也有持久化数据的需求，且想使用上面容器共享的/tmp/data目录，那么可以运行下面的命令启动一个容器：&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# container1为第一个容器的ID，image2为第二个容器运行image的名字。&lt;/span&gt;
docker run -t -i -rm -volumes-from container1 image2 bash
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;workdir&quot;&gt;WORKDIR（切换目录）&lt;/h4&gt;

&lt;p&gt;设置指令，可以多次切换(相当于cd命令)，对RUN,CMD,ENTRYPOINT生效。&lt;/p&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;WORKDIR /path/to/workdir  
&lt;span class=&quot;c&quot;&gt;# 在 /p1/p2 下执行 vim a.txt  &lt;/span&gt;
WORKDIR /p1 WORKDIR p2 RUN vim a.txt  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h4 id=&quot;onbuild&quot;&gt;ONBUILD（在子镜像中执行）&lt;/h4&gt;

&lt;p&gt;ONBUILD 指定的命令在构建镜像时并不执行，而是在它的子镜像中执行.&lt;/p&gt;

&lt;p&gt;查看&lt;a href=&quot;https://www.dockboard.org/docker-quicktip-3-onbuild&quot;&gt;详细参考资料&lt;/a&gt;&lt;/p&gt;

&lt;h4 id=&quot;dockerfilejdktomcat&quot;&gt;创建Dockerfile，构建jdk+tomcat环境&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# Dockerfile文件&lt;/span&gt;
&lt;span class=&quot;c&quot;&gt;# Pull base image  &lt;/span&gt;
FROM ubuntu:13.10  

MAINTAINER zing wang &lt;span class=&quot;s2&quot;&gt;&quot;zing.jian.wang@gmail.com&quot;&lt;/span&gt;  

&lt;span class=&quot;c&quot;&gt;# update source  &lt;/span&gt;
RUN &lt;span class=&quot;nb&quot;&gt;echo&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;deb http://archive.ubuntu.com/ubuntu precise main universe&quot;&lt;/span&gt;&amp;gt; /etc/apt/sources.list  
RUN apt-get update  

&lt;span class=&quot;c&quot;&gt;# Install curl  &lt;/span&gt;
RUN apt-get -y install curl  

&lt;span class=&quot;c&quot;&gt;# Install JDK 7  &lt;/span&gt;
RUN &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tmp &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt;  curl -L &lt;span class=&quot;s1&quot;&gt;'http://download.oracle.com/otn-pub/java/jdk/7u65-b17/jdk-7u65-linux-x64.tar.gz'&lt;/span&gt; -H &lt;span class=&quot;s1&quot;&gt;'Cookie: oraclelicense=accept-securebackup-cookie; gpw_e24=Dockerfile'&lt;/span&gt; | tar -xz  
RUN mkdir -p /usr/lib/jvm  
RUN mv /tmp/jdk1.7.0_65/ /usr/lib/jvm/java-7-oracle/  

&lt;span class=&quot;c&quot;&gt;# Set Oracle JDK 7 as default Java  &lt;/span&gt;
RUN update-alternatives --install /usr/bin/java java /usr/lib/jvm/java-7-oracle/bin/java 300     
RUN update-alternatives --install /usr/bin/javac javac /usr/lib/jvm/java-7-oracle/bin/javac 300     

ENV JAVA_HOME /usr/lib/jvm/java-7-oracle/  

&lt;span class=&quot;c&quot;&gt;# Install tomcat7  &lt;/span&gt;
RUN &lt;span class=&quot;nb&quot;&gt;cd&lt;/span&gt; /tmp &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; curl -L &lt;span class=&quot;s1&quot;&gt;'http://archive.apache.org/dist/tomcat/tomcat-7/v7.0.8/bin/apache-tomcat-7.0.8.tar.gz'&lt;/span&gt; | tar -xz  
RUN mv /tmp/apache-tomcat-7.0.8/ /opt/tomcat7/  

ENV CATALINA_HOME /opt/tomcat7  
ENV PATH &lt;span class=&quot;nv&quot;&gt;$PATH&lt;/span&gt;:&lt;span class=&quot;nv&quot;&gt;$CATALINA_HOME&lt;/span&gt;/bin  
&lt;span class=&quot;c&quot;&gt;# /etc/init.d是开机启动程序的控制脚本，加进来的目的是让tomcat开机启动&lt;/span&gt;
ADD tomcat7.sh /etc/init.d/tomcat7  
RUN chmod 755 /etc/init.d/tomcat7  

&lt;span class=&quot;c&quot;&gt;# Expose ports.  &lt;/span&gt;
EXPOSE 8080  

&lt;span class=&quot;c&quot;&gt;# Define default command.  &lt;/span&gt;
ENTRYPOINT service tomcat7 start &lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; tail -f /opt/tomcat7/logs/catalina.out  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;tomcat7.sh&lt;/p&gt;
&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;JAVA_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/usr/lib/jvm/java-7-oracle/  
&lt;span class=&quot;nb&quot;&gt;export &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;TOMCAT_HOME&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;/opt/tomcat7  

&lt;span class=&quot;k&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;$1&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in  
&lt;/span&gt;start&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  sh &lt;span class=&quot;nv&quot;&gt;$TOMCAT_HOME&lt;/span&gt;/bin/startup.sh  
&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;  
stop&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  sh &lt;span class=&quot;nv&quot;&gt;$TOMCAT_HOME&lt;/span&gt;/bin/shutdown.sh  
&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;  
restart&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;  
  sh &lt;span class=&quot;nv&quot;&gt;$TOMCAT_HOME&lt;/span&gt;/bin/shutdown.sh  
  sh &lt;span class=&quot;nv&quot;&gt;$TOMCAT_HOME&lt;/span&gt;/bin/startup.sh  
&lt;span class=&quot;p&quot;&gt;;;&lt;/span&gt;  
&lt;span class=&quot;k&quot;&gt;esac&lt;/span&gt;  
&lt;span class=&quot;nb&quot;&gt;exit &lt;/span&gt;0
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;原作者已把这些文件上传至&lt;a href=&quot;文件上传到了Github https://github.com/agileshell/dockerfile-jdk-tomcat.git&quot;&gt;github上&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&quot;section&quot;&gt;构建镜像&lt;/h4&gt;

&lt;div class=&quot;language-shell highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;docker build -t zingdocker/jdk-tomcat .  
docker run -d -p 8090:8080 zingdocker/jdk-tomcat  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;默认情况下，tomcat会占用8080端口，刚才在启动container的时候，指定了 -p 8090:8080，映射到宿主机端口就是8090。&lt;/p&gt;

&lt;p&gt;http://&lt;host&gt;:8090 host为主机IP&lt;/host&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://blog.csdn.net/qinyushuang/article/details/43342553&quot;&gt;原文地址&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;参考文章&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://cloud.51cto.com/art/201507/484673.htm&quot;&gt;Dockerfile 简版大全，附赠编写实例&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 02 May 2016 00:00:00 +0800</pubDate>
        <link>http://hehangblog.com/2016/05/02/dockerfile-rules/</link>
        <guid isPermaLink="true">http://hehangblog.com/2016/05/02/dockerfile-rules/</guid>
        
        <category>Docker</category>
        
        
      </item>
    
      <item>
        <title>新的篇章 | Blog</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;下滑这里查看更多内容&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;经历反复的折腾，终于算是安家于此了。很早就想静下心来，写写博客了，但是懒癌一直作用于身，舍不得走。
先后经历了网易博客，博客园，csdn等，发现终究都有些不合人意的地方，最终还是决定自己搭建一个。以便后期扩展使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://blog-image.bj.bcebos.com/common/maimeng.jpg&quot; width=&quot;350&quot; height=&quot;350&quot; /&gt;&lt;/p&gt;

&lt;p&gt;望已能持之以恒。&lt;/p&gt;

&lt;h3 id=&quot;thanks&quot;&gt;Thanks&lt;/h3&gt;
</description>
        <pubDate>Mon, 02 May 2016 00:00:00 +0800</pubDate>
        <link>http://hehangblog.com/2016/05/02/blog-start/</link>
        <guid isPermaLink="true">http://hehangblog.com/2016/05/02/blog-start/</guid>
        
        <category>闲谈</category>
        
        
      </item>
    
  </channel>
</rss>
